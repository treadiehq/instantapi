// Prisma schema for Instant API

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Organization {
  id        String     @id @default(cuid())
  name      String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  users     User[]
  endpoints Endpoint[]
  tunnels   Tunnel[]
  apiKeys   ApiKey[]

  @@index([createdAt])
}

model User {
  id             String       @id @default(cuid())
  email          String       @unique
  organizationId String
  createdAt      DateTime     @default(now())
  lastLoginAt    DateTime?
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  magicLinks     MagicLink[]

  @@index([email])
  @@index([organizationId])
}

model MagicLink {
  id               String    @id @default(cuid())
  userId           String?
  email            String
  type             String    @default("login") // "signup" | "login"
  organizationName String?   // Only for signup links
  token            String    @unique
  expiresAt        DateTime
  usedAt           DateTime?
  createdAt        DateTime  @default(now())
  user             User?     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@index([email])
}

model ApiKey {
  id             String       @id @default(cuid())
  organizationId String
  name           String
  key            String       @unique
  lastUsedAt     DateTime?
  createdAt      DateTime     @default(now())
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, name])
  @@index([key])
  @@index([organizationId])
}

model Endpoint {
  id             String         @id @default(cuid())
  organizationId String?
  language       String         // "javascript" or "python"
  code           String         @db.Text
  kind           String         @default("snippet") // "snippet" | "file" | "webhook"
  name           String?        // optional friendly label
  description    String?        // optional description
  ttlHours       Int            @default(24) // time-to-live in hours
  // Rate limiting
  rateLimit      Int            @default(100)  // max requests per window
  rateLimitWindow Int           @default(60)   // window size in seconds (default: 1 minute)
  createdAt      DateTime       @default(now())
  expiresAt      DateTime
  organization   Organization?  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  ExecutionLog   ExecutionLog[]

  @@index([expiresAt])
  @@index([organizationId])
}

model ExecutionLog {
  id           String   @id @default(cuid())
  endpointId   String
  createdAt    DateTime @default(now())
  durationMs   Int
  success      Boolean
  error        String?  // short error summary
  requestBody  Json?
  responseBody Json?
  // Additional metadata for analytics
  statusCode   Int?     @default(200)
  ipAddress    String?
  userAgent    String?
  Endpoint     Endpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  @@index([endpointId])
  @@index([createdAt])
  @@index([endpointId, createdAt]) // For rate limiting queries
  @@index([success])               // For error rate queries
}

model Tunnel {
  id             String          @id @default(cuid())
  organizationId String?
  targetUrl      String          // e.g. "http://localhost:3000/users/create"
  createdAt      DateTime        @default(now())
  lastSeenAt     DateTime        @default(now())
  isActive       Boolean         @default(true)
  organization   Organization?   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  requests       TunnelRequest[]

  @@index([isActive])
  @@index([lastSeenAt])
  @@index([organizationId])
  // Compound indexes for common query patterns
  @@index([organizationId, isActive]) // List active tunnels by org
  @@index([isActive, lastSeenAt])     // Cleanup job for abandoned tunnels
}

model TunnelRequest {
  id              String              @id @default(cuid())
  tunnelId        String
  createdAt       DateTime            @default(now())
  completedAt     DateTime?           // when request was completed
  method          String
  path            String              // optional extension
  headers         Json
  body            Json?
  status          String              @default("pending") // "pending" | "in-flight" | "completed" | "failed"
  isStreaming     Boolean             @default(false)
  responseStatus  Int?
  responseHeaders Json?
  responseBody    Json?
  durationMs      Int?                // request processing time in milliseconds
  requestSize     Int?                // size of request body in bytes
  responseSize    Int?                // size of response body in bytes
  streamEvents    TunnelStreamEvent[]
  Tunnel          Tunnel              @relation(fields: [tunnelId], references: [id], onDelete: Cascade)

  @@index([tunnelId])
  @@index([status])
  @@index([createdAt])
  @@index([method])                   // Analytics groupBy method
  @@index([tunnelId, createdAt])      // Rate limiting check
  // Compound indexes for critical queries
  @@index([tunnelId, status])         // Poll for pending requests
  @@index([status, createdAt])        // Cleanup job by status and age
  @@index([tunnelId, status, createdAt]) // Combined query optimization
}

model TunnelStreamEvent {
  id        String        @id @default(cuid())
  requestId String
  sequence  Int
  chunk     String        @db.Text
  createdAt DateTime      @default(now())
  Request   TunnelRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([requestId, sequence])
  @@index([createdAt])
}

